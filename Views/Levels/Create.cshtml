@model HealthWellbeing.Models.Level
@using System
@using System.Linq

@{
    ViewData["Title"] = "Create";

    var cats = ViewBag.CategoriesList as IEnumerable<string> ?? Enumerable.Empty<string>();

    // LevelNumber prefill (avoid showing 0)
    var levelNumberValue = "";
    if (ViewData.ModelState.TryGetValue("LevelNumber", out var ms) && ms?.AttemptedValue != null)
    {
        levelNumberValue = ms.AttemptedValue;
    }
    else if (Model?.LevelNumber > 0)
    {
        levelNumberValue = Model.LevelNumber.ToString();
    }

    // Category prefill (preserve attempted value on validation error)
    var categoryValue = "";
    if (ViewData.ModelState.TryGetValue("LevelCategory", out var cms) && cms?.AttemptedValue != null)
    {
        categoryValue = cms.AttemptedValue;
    }
    else if (!string.IsNullOrWhiteSpace(Model?.LevelCategory))
    {
        categoryValue = Model.LevelCategory;
    }

    var categoryInList = cats.Any(c => string.Equals(c, categoryValue, StringComparison.OrdinalIgnoreCase));
    var showNewBox = true;
}

<div class="container py-4">
    <div class="row justify-content-center">
        <div class="col-lg-6 col-md-8">
            <div class="card shadow-sm">
                <div class="card-header bg-primary text-white">
                    <h5 class="mb-0">Create Level</h5>
                </div>

                <div class="card-body">
                    @* Pretty validation summary (shows server & client errors) *@

                    <form asp-action="Create" method="post" id="createLevelForm" novalidate>
                        @Html.AntiForgeryToken()

                        <div class="form-floating mb-3">
                            <input asp-for="LevelNumber"
                                   type="number"
                                   min="1" max="100" step="1"
                                   value="@(levelNumberValue)"
                                   class="form-control @(ViewData.ModelState["LevelNumber"]?.Errors.Count > 0 ? "is-invalid" : "")"
                                   placeholder="Level number" />
                            <label asp-for="LevelNumber">Level number</label>
                            <span asp-validation-for="LevelNumber" class="invalid-feedback"></span>
                        </div>

                        <div class="mb-3">
                            <label for="categorySelect" class="form-label">Category</label>
                            <div class="d-flex gap-2 align-items-start">
                                <!-- select is the bound element (client validation works against this) -->
                                <select asp-for="LevelCategory" id="categorySelect" class="form-select bg-white @(ViewData.ModelState["LevelCategory"]?.Errors.Count > 0 ? "is-invalid" : "")" aria-label="Category selector">
                                    @foreach (var c in cats)
                                    {
                                        <option value="@c">@c</option>
                                    }

                                    @if (showNewBox)
                                    {
                                        <option value="__new" selected>-- New category --</option>
                                    }
                                    else
                                    {
                                        <option value="__new">-- New category --</option>
                                    }
                                </select>

                                <!-- free text box for new category (not bound) -->
                                <input id="categoryNew"
                                       name="categoryNew"
                                       type="text"
                                       class="form-control @(ViewData.ModelState["LevelCategory"]?.Errors.Count > 0 ? "is-invalid" : "")"
                                       placeholder="Type new category"
                                       value="@(showNewBox? categoryValue : "")"
                                       style="min-width:220px;@(showNewBox ? "" : "display:none;")" />
                            </div>

                            <span asp-validation-for="LevelCategory" class="invalid-feedback"></span>
                        </div>

                        <div class="form-floating mb-3">
                            <textarea asp-for="Description"
                                      class="form-control @(ViewData.ModelState["Description"]?.Errors.Count > 0 ? "is-invalid" : "")"
                                      placeholder="Description" style="height:120px"></textarea>
                            <label asp-for="Description">Description</label>
                            <span asp-validation-for="Description" class="invalid-feedback"></span>
                        </div>

                        <div class="d-flex justify-content-between">
                            <a asp-action="Index" class="btn btn-outline-secondary">Cancel</a>
                            <button type="submit" class="btn btn-primary">Create Level</button>
                        </div>
                    </form>
                </div>
            </div>
        </div>
    </div>
</div>

@section Scripts {
    @{
        await Html.RenderPartialAsync("_ValidationScriptsPartial");
    }

    <style>
        /* Small polish for validation visuals */
        .invalid-feedback {
            display: block;
        }

        #validationSummary ul {
            margin: 0;
            padding-left: 1.25rem;
        }

        .form-control.is-invalid, .form-select.is-invalid {
            box-shadow: 0 0 0 0.15rem rgba(220,53,69,.08);
            border-color: #dc3545;
        }
    </style>

    <script>
        document.addEventListener('DOMContentLoaded', function () {
            var select = document.getElementById('categorySelect');
            var newInput = document.getElementById('categoryNew');

            function setNewVisibility(show) {
                newInput.style.display = show ? '' : 'none';
                if (show) newInput.focus();
            }

            function ensureOptionAndSelect(value) {
                // Apenas usa a caixa de texto, nunca adiciona ao dropdown
                if (select.value === "__new") {
                    return; 
                }
            }


            // initial visibility is already server-rendered; keep JS in sync
            setNewVisibility(select.value === "__new");

            select.addEventListener('change', function () {
                setNewVisibility(this.value === "__new");
                // update validation display when user changes select
                toggleValidationForElement(select);
            });

            // create final option only on blur or Enter to avoid incremental prefixes
            if (newInput) {
                newInput.addEventListener('keydown', function (e) {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        var v = this.value.trim();
                        if (v.length > 0) ensureOptionAndSelect(v);
                        this.blur();
                    }
                });

                newInput.addEventListener('blur', function () {
                    var v = this.value.trim();
                    if (v.length > 0) ensureOptionAndSelect(v);
                });

                newInput.addEventListener('input', function () {
                    // mirror live validation state for the new text box
                    toggleValidationForElement(newInput);
                });
            }

            // Before submit fix __new
            var form = document.getElementById('createLevelForm');

            form.addEventListener('submit', function (e) {

                if (select.value === "__new") {

                    const typed = newInput.value.trim();

                    if (typed.length > 0) {
                        const option = document.createElement('option');
                        option.value = typed;
                        option.textContent = typed;
                        select.appendChild(option);

                        select.value = typed;
                    } else {
                        select.value = "";
                    }
                }
            });


            // helper to toggle is-invalid class on an element based on validation message presence
            function toggleValidationForElement(el) {
                if (!el) return;
                // find the validation message node that corresponds to the bound name
                var name = el.name || el.getAttribute('asp-for') || el.id;
                var message = document.querySelector('[data-valmsg-for="' + (name || '') + '"]');
                if (message && message.innerText.trim().length > 0) {
                    el.classList.add('is-invalid');
                } else {
                    el.classList.remove('is-invalid');
                }
            }

            // ensure unobtrusive validator parsing if necessary and wire pretty client-side handlers
            if (typeof jQuery !== 'undefined' && typeof jQuery.validator !== 'undefined' && typeof jQuery.validator.unobtrusive !== 'undefined') {
                var $form = $('#createLevelForm');
                if (!$form.data('validator')) {
                    $.validator.unobtrusive.parse($form);
                }

                // update summary & field classes when client validation runs
                $form.on('invalid-form.validate', function (e, validator) {
                    var summary = $('#validationSummary');
                    if (validator.numberOfInvalids()) {
                        var list = $('<ul/>');
                        $.each(validator.errorList, function () {
                            list.append($('<li/>').text(this.message));
                        });
                        summary.html(list).removeClass('d-none');
                    } else {
                        summary.addClass('d-none').empty();
                    }

                    // mark inputs with errors
                    $form.find('.is-invalid').removeClass('is-invalid');
                    $.each(validator.errorList, function () {
                        $(this.element).addClass('is-invalid');
                    });
                });

                // when fields become valid, remove error styles
                $form.on('keyup change', 'input, select, textarea', function () {
                    var $el = $(this);
                    var name = $el.attr('name');
                    var message = $('[data-valmsg-for="' + name + '"]');
                    if (message && message.text().trim().length === 0) {
                        $el.removeClass('is-invalid');
                    }
                });
            } else {
                // non-jQuery fallback: reflect server-side validation state already rendered
                // and keep newInput in sync when user types
                if (newInput) {
                    newInput.addEventListener('input', function () {
                        toggleValidationForElement(newInput);
                    });
                }
            }

            // initial pass to mark server-side invalid fields
            Array.from(document.querySelectorAll('[data-valmsg-for]')).forEach(function (msg) {
                var elName = msg.getAttribute('data-valmsg-for');
                var field = document.querySelector('[name="' + elName + '"]') || document.getElementById(elName);
                if (msg.innerText.trim().length > 0 && field) {
                    field.classList.add('is-invalid');
                }
            });
        });
    </script>
}
